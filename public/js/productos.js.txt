// public/JS/productos.astro
// Versión corregida: crossfade entre imágenes (sin parpadeo), preload, reveal circular visible.

let contenedor;
let modal;
let modalOverlay;
let modalImg;      // referencia al "front" img visible
let modalImgBack;  // referencia al "back" img para crossfade
let prevBtn;
let nextBtn;

let currentImages = [];
let currentIndex = 0;
let isAnimating = false;
let lastFocusedElement = null;
let imageWrapper = null;

// Inyectar estilos (full-screen, reveal circular, crossfade)
(function injectModalStyles() {
  const css = `
  /* Modal full-screen */
  #modal { display: none; }
  #modal.open {
    display: flex !important;
    position: fixed;
    inset: 0;
    width: 100vw;
    height: 100vh;
    align-items: center;
    justify-content: center;
    z-index: 9999;
    -webkit-tap-highlight-color: transparent;
  }

  /* Overlay full-screen */
  #modal .modal-overlay {
    position: fixed;
    inset: 0;
    width: 100vw;
    height: 100vh;
    background: rgba(0,0,0,0.45);
    backdrop-filter: blur(6px);
    opacity: 0;
    animation: modalOverlayIn 320ms ease forwards;
  }
  #modal.closing .modal-overlay {
    animation: modalOverlayOut 260ms ease forwards;
  }
  @keyframes modalOverlayIn { from { opacity: 0; } to { opacity: 1; } }
  @keyframes modalOverlayOut { from { opacity: 1; } to { opacity: 0; } }

  /* Contenido centrado con reveal circular (clip-path) */
  #modal .modal-content {
    position: relative;
    z-index: 1;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    width: 100%;
    max-width: 100%;
    height: 90vh;
    padding: 12px;
    box-sizing: border-box;
    overflow: visible;
    clip-path: circle(0% at 50% 50%);
    animation: modalRevealIn 420ms cubic-bezier(.2,.9,.2,1) forwards;
  }
  #modal.closing .modal-content {
    animation: modalRevealOut 320ms cubic-bezier(.2,.9,.2,1) forwards;
  }
  @keyframes modalRevealIn {
    0% { clip-path: circle(0% at 50% 50%); opacity: 0; transform: scale(0.98); }
    60% { opacity: 1; transform: scale(1.01); }
    100% { clip-path: circle(150% at 50% 50%); transform: scale(1); opacity: 1; }
  }
  @keyframes modalRevealOut {
    0% { clip-path: circle(150% at 50% 50%); opacity: 1; transform: scale(1); }
    100% { clip-path: circle(0% at 50% 50%); opacity: 0; transform: scale(0.98); }
  }

  /* Wrapper para la imagen: ocupa la mayor parte del modal, dejando espacio fijo para footer */
  #modal .modal-image-wrapper {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 100%;
    height: calc(100% - 88px);
    overflow: hidden;
    position: relative;
    touch-action: pan-y;
    transform: translateX(0);
  }

  /* Dos imágenes apiladas para crossfade */
  #modal .modal-image-wrapper img {
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    max-width: 100%;
    max-height: 100%;
    object-fit: contain;
    display: block;
    opacity: 0;
    transition: opacity 320ms cubic-bezier(.2,.9,.2,1), transform 260ms ease;
    will-change: opacity, transform;
  }

  /* front image visible */
  #modal .modal-image-wrapper img.front {
    opacity: 1;
  }

  /* Animaciones al cambiar imagen (clases aplicadas temporalmente a front/back) */
  #modal .modal-image-wrapper img.slide-left { transform: translate(-60%, -50%); opacity: 0; }
  #modal .modal-image-wrapper img.slide-right { transform: translate(-40%, -50%); opacity: 0; }
  #modal .modal-image-wrapper img.slide-in { transform: translate(-50%, -50%); opacity: 1; }

  /* Footer con botones: altura fija para evitar saltos */
  #modal .modal-footer {
    width: 100%;
    min-height: 88px;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 20px;
    margin-top: 8px;
    box-sizing: border-box;
  }

  /* Botones nav */
  #modal .nav-btn {
    width: 48px;
    height: 48px;
    border-radius: 999px;
    background: rgba(0,0,0,0.5);
    color: white;
    border: none;
    font-size: 20px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
  }
  #modal .nav-btn[disabled] { opacity: 0.35; cursor: default; }

  /* Feedback visual del wrapper durante swipe (se revierte) */
  #modal .modal-image-wrapper.swipe-feedback {
    transition: transform 180ms ease, opacity 180ms ease;
  }
  `;
  const style = document.createElement('style');
  style.setAttribute('data-generated', 'productos-modal-styles');
  style.textContent = css;
  document.head.appendChild(style);
})();

// Helper: preload image, devuelve Promise
function preloadImage(src) {
  return new Promise((resolve, reject) => {
    if (!src) return reject(new Error('No src'));
    const img = new Image();
    img.onload = () => resolve(src);
    img.onerror = () => reject(new Error('Error cargando ' + src));
    img.src = src;
  });
}

// Cargar productos y renderizar
async function cargarProductos() {
  try {
    const res = await fetch('/productos/productos.json', { cache: 'no-store' });
    if (!res.ok) throw new Error('No se pudo cargar productos');
    const productos = await res.json();
    renderProductos(productos);
  } catch (err) {
    console.error(err);
    if (contenedor) contenedor.innerHTML = '<p class="text-red-600">Error cargando productos.</p>';
  }
}

function renderProductos(productos) {
  if (!contenedor) return;
  contenedor.innerHTML = '';
  const fragment = document.createDocumentFragment();

  productos.forEach((p) => {
    const card = document.createElement('article');
    card.className = 'producto bg-white border border-red-400 rounded-lg shadow-sm p-3 w-56 flex flex-col';
    card.innerHTML = `
      <div class="galeria flex gap-2 overflow-x-auto pb-2 -mx-1"></div>
      <h2 class="mt-2 text-sm font-semibold"></h2>
      <p class="text-gray-700 text-sm"></p>
      <p class="mt-2 font-medium text-green-600"></p>
      <div class="mt-3">
        <a class="comprar-btn inline-block bg-emerald-500 text-white px-3 py-1 rounded-md font-semibold" href="#">Comprar</a>
      </div>
    `;
    const galeria = card.querySelector('.galeria');
    card.querySelector('h2').textContent = p.nombre || '';
    card.querySelector('p.text-gray-700').textContent = p.descripcion || '';
    card.querySelector('p.text-green-600').textContent = `$${Number(p.precio || 0).toFixed(2)}`;

    (Array.isArray(p.imagenes) ? p.imagenes : []).forEach((src, i) => {
      const wrapper = document.createElement('div');
      wrapper.className = 'imagen-wrapper flex-none min-w-[100px] h-[100px] bg-gray-100 rounded-md overflow-hidden cursor-pointer';
      const img = document.createElement('img');
      img.src = src;
      img.alt = `${p.nombre || 'Producto'} ${i + 1}`;
      img.loading = 'lazy';
      img.className = 'w-full h-full object-cover block transition-transform duration-200';
      wrapper.appendChild(img);
      wrapper.addEventListener('click', (ev) => {
        abrirModal(p.imagenes, i, ev.currentTarget);
      });
      galeria.appendChild(wrapper);
    });

    fragment.appendChild(card);
  });

  contenedor.appendChild(fragment);
}

// Asegurar estructura del modal (crear two imgs front/back)
function ensureModalStructure() {
  if (!modal) return;
  const content = modal.querySelector('#modalContent') || modal.querySelector('.modal-content');
  if (!content) return;

  imageWrapper = modal.querySelector('.modal-image-wrapper');
  if (!imageWrapper) {
    imageWrapper = document.createElement('div');
    imageWrapper.className = 'modal-image-wrapper';
    // crear dos imgs apiladas: back y front
    const imgBack = document.createElement('img');
    imgBack.className = 'back';
    imgBack.alt = 'imagen back';
    const imgFront = document.createElement('img');
    imgFront.className = 'front';
    imgFront.alt = 'imagen front';
    // si ya existía modalImg en DOM, removerlo
    const existing = modal.querySelector('#modal-img');
    if (existing) existing.remove();
    imageWrapper.appendChild(imgBack);
    imageWrapper.appendChild(imgFront);
    content.insertBefore(imageWrapper, content.firstChild);
    // asignar referencias
    modalImgBack = imgBack;
    modalImg = imgFront;
  } else {
    // si ya existe, intentar asignar referencias a las imgs internas
    modalImgBack = imageWrapper.querySelector('img.back') || imageWrapper.querySelector('img:nth-child(1)');
    modalImg = imageWrapper.querySelector('img.front') || imageWrapper.querySelector('img:nth-child(2)');
    // si no existen, crear
    if (!modalImgBack) {
      modalImgBack = document.createElement('img');
      modalImgBack.className = 'back';
      imageWrapper.insertBefore(modalImgBack, imageWrapper.firstChild);
    }
    if (!modalImg) {
      modalImg = document.createElement('img');
      modalImg.className = 'front';
      imageWrapper.appendChild(modalImg);
    }
  }

  // footer
  let footer = modal.querySelector('.modal-footer');
  if (!footer) {
    footer = document.createElement('div');
    footer.className = 'modal-footer';
    if (prevBtn && prevBtn.parentElement !== footer) {
      try { prevBtn.parentElement.removeChild(prevBtn); } catch (e) {}
      footer.appendChild(prevBtn);
    }
    let cerrar = modal.querySelector('.cerrar-btn');
    if (!cerrar) {
      cerrar = document.createElement('button');
      cerrar.className = 'cerrar-btn';
      cerrar.textContent = 'Cerrar';
      cerrar.addEventListener('click', cerrarModal);
    } else {
      cerrar.addEventListener('click', cerrarModal);
    }
    footer.appendChild(cerrar);
    if (nextBtn && nextBtn.parentElement !== footer) {
      try { nextBtn.parentElement.removeChild(nextBtn); } catch (e) {}
      footer.appendChild(nextBtn);
    }
    content.appendChild(footer);
  }
}

// Abrir modal (reveal circular) — forzar reinicio de animación
function abrirModal(imagenes, index, openerElement = null) {
  if (!modal) return;
  if (!Array.isArray(imagenes) || imagenes.length === 0) return;
  currentImages = imagenes;
  currentIndex = Math.max(0, Math.min(index || 0, currentImages.length - 1));
  lastFocusedElement = openerElement || document.activeElement;

  ensureModalStructure();

  isAnimating = true;
  disableNav(true);

  // Reset transforms y clases
  if (modalImg) {
    modalImg.className = 'front';
    modalImg.style.opacity = '';
    modalImg.style.transform = '';
  }
  if (modalImgBack) {
    modalImgBack.className = 'back';
    modalImgBack.style.opacity = '';
    modalImgBack.style.transform = '';
  }
  if (imageWrapper) {
    imageWrapper.style.transform = '';
    imageWrapper.style.opacity = '';
    imageWrapper.classList.remove('swipe-feedback');
  }

  // Preload current image y setear en front sin parpadeo
  preloadImage(currentImages[currentIndex]).then(() => {
    modalImg.src = currentImages[currentIndex];
    modalImg.alt = `Imagen ${currentIndex + 1}`;
  }).catch(() => {
    modalImg.src = '';
  });

  // Mostrar modal con clase open (full-screen)
  // Para forzar que la animación de reveal se vea, removemos y reañadimos la clase 'open' con reflow
  modal.classList.remove('open', 'closing');
  void modal.offsetWidth; // reflow
  modal.classList.add('open');

  // Forzar reflow para que clip-path animation arranque
  void modal.querySelector('.modal-content')?.offsetWidth;

  setTimeout(() => {
    isAnimating = false;
    disableNav(false);
    const cerrar = modal.querySelector('.cerrar-btn');
    if (cerrar) cerrar.focus();
  }, 480);

  document.body.style.overflow = 'hidden';
}

// Cerrar modal (animación inversa del reveal)
function cerrarModal() {
  if (!modal || !modal.classList.contains('open') || isAnimating) return;
  isAnimating = true;
  disableNav(true);

  modal.classList.remove('open');
  modal.classList.add('closing');

  const onAnimationEnd = () => {
    modal.classList.remove('closing');
    try { if (modalImg) modalImg.src = ''; if (modalImgBack) modalImgBack.src = ''; } catch (e) {}
    document.body.style.overflow = '';
    isAnimating = false;
    disableNav(false);
    if (lastFocusedElement && typeof lastFocusedElement.focus === 'function') {
      lastFocusedElement.focus();
    }
    modal.removeEventListener('animationend', onAnimationEnd);
  };

  modal.addEventListener('animationend', onAnimationEnd);
  setTimeout(() => {
    if (isAnimating) onAnimationEnd();
  }, 560);
}

// Prev / Next con crossfade (preload + fade)
function prevImage() {
  if (!currentImages.length || isAnimating) return;
  const prevIndex = (currentIndex - 1 + currentImages.length) % currentImages.length;
  changeImageCrossfade(prevIndex, 'left');
}

function nextImage() {
  if (!currentImages.length || isAnimating) return;
  const nextIndex = (currentIndex + 1) % currentImages.length;
  changeImageCrossfade(nextIndex, 'right');
}

// Crossfade: preload new src into back image, then fade back->front
async function changeImageCrossfade(newIndex, direction = 'right') {
  if (!modalImg || !modalImgBack) return;
  if (newIndex === currentIndex) return;
  isAnimating = true;
  disableNav(true);

  const newSrc = currentImages[newIndex];
  try {
    await preloadImage(newSrc);
  } catch (err) {
    console.warn('No se pudo precargar', newSrc);
    isAnimating = false;
    disableNav(false);
    return;
  }

  // preparar back con la nueva imagen
  modalImgBack.src = newSrc;
  modalImgBack.alt = `Imagen ${newIndex + 1}`;
  // asegurar clases iniciales
  modalImgBack.className = 'back';
  modalImg.className = 'front';

  // aplicar clase de salida a front para dar sensación de movimiento
  modalImg.classList.add(direction === 'left' ? 'slide-right' : 'slide-left');

  // forzar reflow
  void modalImg.offsetWidth;

  // iniciar crossfade: back entra (slide-in), front sale (opacity->0)
  modalImgBack.classList.add('slide-in');
  // front ya tiene slide-left/right que reduce su opacidad por CSS

  // después de la transición, swap roles: front <- back
  setTimeout(() => {
    // limpiar clases
    modalImg.classList.remove('slide-left', 'slide-right', 'front');
    modalImgBack.classList.remove('slide-in', 'back');

    // swap: poner src del back en front (para mantener la referencia modalImg como front)
    // en vez de swap de nodos, simplemente intercambiamos srcs y clases para mantener referencias
    const tempSrc = modalImgBack.src;
    modalImg.src = tempSrc;
    modalImg.alt = modalImgBack.alt;

    // limpiar back
    modalImgBack.src = '';
    modalImgBack.alt = '';

    // asegurar front visible
    modalImg.classList.add('front');
    void modalImg.offsetWidth;

    currentIndex = newIndex;
    isAnimating = false;
    disableNav(false);
  }, 360); // tiempo ligeramente mayor que la transición CSS (320ms)
}

function disableNav(disabled) {
  if (prevBtn) prevBtn.disabled = !!disabled;
  if (nextBtn) nextBtn.disabled = !!disabled;
  const cerrar = modal ? modal.querySelector('.cerrar-btn') : null;
  if (cerrar) cerrar.disabled = !!disabled;
}

// Swipe: feedback en wrapper, imagen permanece centrada
(function enableSwipe() {
  let startX = 0;
  let startY = 0;
  let isTouching = false;
  let moved = false;
  const threshold = 40;
  const restraint = 75;

  function onTouchStart(e) {
    if (!modal || !modal.classList.contains('open') || isAnimating) return;
    const t = e.touches ? e.touches[0] : e;
    startX = t.clientX;
    startY = t.clientY;
    isTouching = true;
    moved = false;
    if (imageWrapper) {
      imageWrapper.style.transition = '';
      imageWrapper.style.transform = '';
      imageWrapper.style.opacity = '';
      imageWrapper.classList.remove('swipe-feedback');
    }
    if (modalImg) {
      modalImg.style.transition = '';
      modalImg.style.transform = '';
      modalImg.style.opacity = '';
    }
    if (modalImgBack) {
      modalImgBack.style.transition = '';
      modalImgBack.style.transform = '';
      modalImgBack.style.opacity = '';
    }
  }

  function onTouchMove(e) {
    if (!isTouching || !imageWrapper) return;
    const t = e.touches ? e.touches[0] : e;
    const dx = t.clientX - startX;
    const dy = t.clientY - startY;

    if (Math.abs(dy) > Math.abs(dx) && Math.abs(dy) > restraint) {
      isTouching = false;
      imageWrapper.style.transform = '';
      imageWrapper.style.opacity = '';
      return;
    }

    if (Math.abs(dx) > 6) {
      e.preventDefault?.();
      moved = true;
      imageWrapper.style.transform = `translateX(${dx * 0.18}px)`;
      imageWrapper.style.opacity = `${Math.max(0.35, 1 - Math.abs(dx) / 800)}`;
    }
  }

  function onTouchEnd(e) {
    if (!imageWrapper) return;
    if (!moved) {
      isTouching = false;
      imageWrapper.style.transform = '';
      imageWrapper.style.opacity = '';
      return;
    }
    const t = (e.changedTouches && e.changedTouches[0]) || e;
    const dx = t.clientX - startX;

    if (dx < -threshold) {
      imageWrapper.style.transition = 'transform 180ms ease, opacity 180ms ease';
      imageWrapper.style.transform = `translateX(-40%)`;
      imageWrapper.style.opacity = '0.25';
      setTimeout(() => {
        imageWrapper.style.transition = '';
        imageWrapper.style.transform = '';
        imageWrapper.style.opacity = '';
        nextImage();
      }, 160);
    } else if (dx > threshold) {
      imageWrapper.style.transition = 'transform 180ms ease, opacity 180ms ease';
      imageWrapper.style.transform = `translateX(40%)`;
      imageWrapper.style.opacity = '0.25';
      setTimeout(() => {
        imageWrapper.style.transition = '';
        imageWrapper.style.transform = '';
        imageWrapper.style.opacity = '';
        prevImage();
      }, 160);
    } else {
      imageWrapper.style.transition = 'transform 180ms ease, opacity 180ms ease';
      imageWrapper.style.transform = '';
      imageWrapper.style.opacity = '';
      setTimeout(() => { imageWrapper.style.transition = ''; }, 200);
    }

    isTouching = false;
    moved = false;
  }

  window.__swipeHandlers = { onTouchStart, onTouchMove, onTouchEnd };
})();

// Inicialización: obtener referencias y añadir listeners
function init() {
  contenedor = document.getElementById('contenedor-productos');
  modal = document.getElementById('modal');
  modalOverlay = document.getElementById('modalOverlay');
  // NOTA: modalImg y modalImgBack se crean en ensureModalStructure
  prevBtn = document.getElementById('prevBtn');
  nextBtn = document.getElementById('nextBtn');

  if (modalOverlay) modalOverlay.addEventListener('click', () => cerrarModal());
  if (prevBtn) prevBtn.addEventListener('click', (e) => { e.stopPropagation(); prevImage(); });
  if (nextBtn) nextBtn.addEventListener('click', (e) => { e.stopPropagation(); nextImage(); });

  document.addEventListener('keydown', (e) => {
    if (!modal || !modal.classList.contains('open')) return;
    if (e.key === 'Escape') { e.preventDefault(); cerrarModal(); }
    else if (e.key === 'ArrowLeft') { e.preventDefault(); prevImage(); }
    else if (e.key === 'ArrowRight') { e.preventDefault(); nextImage(); }
  });

  // swipe handlers
  if (modal && window.__swipeHandlers) {
    modal.addEventListener('touchstart', window.__swipeHandlers.onTouchStart, { passive: false });
    modal.addEventListener('touchmove', window.__swipeHandlers.onTouchMove, { passive: false });
    modal.addEventListener('touchend', window.__swipeHandlers.onTouchEnd);
    modal.addEventListener('mousedown', (e) => {
      if (e.button !== 0) return;
      window.__swipeHandlers.onTouchStart(e);
      const onMouseMove = (ev) => window.__swipeHandlers.onTouchMove(ev);
      const onMouseUp = (ev) => {
        window.__swipeHandlers.onTouchEnd(ev);
        window.removeEventListener('mousemove', onMouseMove);
        window.removeEventListener('mouseup', onMouseUp);
      };
      window.addEventListener('mousemove', onMouseMove);
      window.addEventListener('mouseup', onMouseUp);
    });
  }

  cargarProductos();
}
// Ejecutar init cuando el DOM esté listo
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', init);
} else {
  init();
}

// Exponer cerrarModal para compatibilidad con onclick inline
window.cerrarModal = function() { cerrarModal(); };
